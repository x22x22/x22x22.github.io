<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vLLM Long Text Embedding Chunked Processing Test Results</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            background-color: #f8f9fa;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem;
            border-radius: 10px;
            margin-bottom: 2rem;
            text-align: center;
        }
        
        .summary {
            background: white;
            padding: 2rem;
            border-radius: 10px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .model-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin: 2rem 0;
        }
        
        .model-card {
            background: white;
            border-radius: 10px;
            padding: 1.5rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-left: 4px solid #667eea;
        }
        
        .model-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: #333;
        }
        
        .pooling-result {
            margin: 0.5rem 0;
            padding: 0.5rem;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .pooling-result.best {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            font-weight: bold;
        }
        
        .pooling-result.normal {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
        }
        
        .score {
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        
        .controls {
            background: white;
            padding: 1.5rem;
            border-radius: 10px;
            margin: 2rem 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .control-group {
            margin: 1rem 0;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
        }
        
        .control-group select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }
        
        .detail-results {
            background: white;
            padding: 2rem;
            border-radius: 10px;
            margin: 2rem 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: none;
        }
        
        .metrics-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }
        
        .metrics-table th,
        .metrics-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        .metrics-table th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        
        .metrics-table tr:hover {
            background-color: #f5f5f5;
        }
        
        .loading {
            text-align: center;
            padding: 2rem;
            color: #666;
        }
        
        .error {
            color: #dc3545;
            padding: 1rem;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 5px;
            margin: 1rem 0;
        }
        
        .highlight {
            background-color: #fff3cd;
            padding: 1rem;
            border-left: 4px solid #ffc107;
            margin: 1rem 0;
        }
        
        .conclusion {
            background: white;
            color: #333;
            padding: 2rem;
            border-radius: 10px;
            margin: 2rem 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-left: 4px solid #6f42c1;
        }
        
        .conclusion h3 {
            color: #6f42c1;
            margin-top: 0;
        }
        
        .language-switcher {
            position: fixed;
            top: 20px;
            right: max(20px, calc((100vw - 1400px) / 2 + 20px));
            z-index: 1000;
            display: flex;
            gap: 10px;
        }
        
        @media (max-width: 1440px) {
            .language-switcher {
                right: 20px;
            }
        }
        
        .language-btn {
            padding: 8px 16px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .language-btn:hover {
            background: #667eea;
            color: white;
        }
        
        .language-btn.active {
            background: #667eea;
            color: white;
        }
    </style>
  </head>
<body>
    <div class="language-switcher">
        <button class="language-btn active" onclick="switchLanguage('en')">EN</button>
        <button class="language-btn" onclick="switchLanguage('zh')">中文</button>
    </div>
    
    <div class="header">
        <h1 data-i18n="page.title">vLLM Long Text Embedding Chunked Processing Test Results</h1>
        <p data-i18n="page.subtitle">Evaluating the performance of different pooling aggregation strategies in long text embedding tasks</p>
    </div>

    <div class="summary">
        <h2 data-i18n="summary.title">📊 Test Results Summary</h2>
        <p data-i18n="summary.description">Following the PR reviewer's recommendations, we tested three core models, plus two additional Qwen models (supporting 32k context) for result analysis:</p>
        
        <div class="highlight">
            <strong data-i18n="summary.metrics.label">Evaluation Metrics:</strong> <span data-i18n="summary.metrics.description">Using ndcg_at_10 metric to measure model performance on LEMBNeedleRetrieval and LEMBPasskeyRetrieval tasks.</span>
        </div>

        <div style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; padding: 1.5rem; border-radius: 10px; margin: 1rem 0;">
            <h4 style="margin-top: 0; display: flex; align-items: center;">
                🌟 <span style="margin-left: 0.5rem;" data-i18n="highlight.title">Outstanding Performance: Qwen3-Embedding-4B Long Text Processing</span>
            </h4>
            <p style="margin-bottom: 1rem;">
                <strong>Qwen3-Embedding-4B</strong> <span data-i18n="highlight.description">demonstrates exceptional long text processing capabilities under LAST pooling:</span>
                <br>• <strong>34816 tokens</strong>: <span data-i18n="highlight.score1">PasskeyRetrieval achieves</span> <strong id="score-34816">--</strong> <span data-i18n="highlight.score.unit">score</span>
                <br>• <strong>36864 tokens</strong>: <span data-i18n="highlight.score2">PasskeyRetrieval maintains</span> <strong id="score-36864">--</strong> <span data-i18n="highlight.score.unit">score</span>
                <br>• <span data-i18n="highlight.conclusion">This proves that chunked processing technology can maintain excellent performance even when <strong>exceeding native 32k context limits</strong>!</span>
            </p>
            
            <!-- 添加专门的Qwen3-Embedding-4B性能图表 -->
            <div style="background: rgba(255,255,255,0.15); border-radius: 8px; padding: 1rem; margin-top: 1rem;">
                <h5 style="margin-top: 0; margin-bottom: 1rem;" data-i18n="highlight.chart.title">Performance Chart: Ultra-Long Text Processing</h5>
                <div style="background: white; border-radius: 6px; padding: 1rem;">
                    <div style="position: relative; height: 300px;">
                        <canvas id="qwenPerformanceChart"></canvas>
                    </div>
                    <div style="margin-top: 0.5rem; font-size: 0.85rem; color: #666; text-align: center;">
                        <span data-i18n="highlight.chart.note">32k context limit highlighted in red dashed line</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="modelResults" class="model-grid">
            <div class="loading" data-i18n="loading.text">Loading test results...</div>
        </div>
    </div>

    <div class="conclusion">
        <h3 data-i18n="conclusion.title">🎯 Key Findings and Conclusions</h3>
        
        <div style="background: rgba(40, 167, 69, 0.1); border: 2px solid #28a745; border-radius: 8px; padding: 1rem; margin: 1rem 0;">
            <h4 style="color: #28a745; margin-top: 0;" data-i18n="conclusion.breakthrough.title">🌟 Notable Achievement: Ultra-Long Text Processing Capability Validation</h4>
            <p style="margin-bottom: 0;">
                <strong>Qwen3-Embedding-4B</strong> <span data-i18n="conclusion.breakthrough.description">achieved <strong>excellent ultra-long text processing performance</strong> under LAST pooling: At extreme lengths of 34816 and 36864 tokens (exceeding the native 32k limit by 15%+), the PasskeyRetrieval task still maintains a <strong>near-perfect score of</strong></span> <strong id="conclusion-score">--</strong><span data-i18n="conclusion.breakthrough.suffix">, providing strong performance validation for vLLM's chunked processing technology!</span>
            </p>
        </div>
        
        <h4 data-i18n="conclusion.differences.title">Analysis of Aggregation Strategy Performance</h4>
        <p data-i18n="conclusion.differences.intro">Contrary to the assumption that "mean aggregation always performs better", our comprehensive test results reveal:</p>
        <ul>
            <li><strong data-i18n="conclusion.differences.point1.title">Native pooling types generally perform best:</strong> <span data-i18n="conclusion.differences.point1.desc">4 out of 5 models achieved highest scores with their native pooling types</span></li>
            <li><strong data-i18n="conclusion.differences.point2.title">MEAN aggregation is not a universal solution:</strong> <span data-i18n="conclusion.differences.point2.desc">For native LAST models, LAST aggregation significantly outperforms MEAN aggregation</span></li>
            <li><strong data-i18n="conclusion.differences.point3.title">Interesting exception:</strong> <span data-i18n="conclusion.differences.point3.desc">Although ibm-granite model is natively CLS, MEAN aggregation performs best</span></li>
        </ul>
        
        <h4 data-i18n="conclusion.effectiveness.title">Practical Effects of Chunked Processing</h4>
        <p data-i18n="conclusion.effectiveness.intro">Ultra-long text testing of Qwen models (34816, 36864 tokens) proves the effectiveness of chunked processing:</p>
        <ul>
            <li><strong data-i18n="conclusion.effectiveness.point1.title">🌟 Qwen3-Embedding-4B shows outstanding performance:</strong> <span data-i18n="conclusion.effectiveness.point1.desc">Under LAST aggregation, even exceeding the native 32k context limit, PasskeyRetrieval task still maintains a high score of</span> <strong id="effectiveness-score">--</strong><span data-i18n="conclusion.effectiveness.point1.suffix"></span></li>
            <li><strong data-i18n="conclusion.effectiveness.point2.title">Technical validation:</strong> <span data-i18n="conclusion.effectiveness.point2.desc">This is the first proof that chunked processing technology can maintain near-native performance on ultra-long texts</span></li>
            <li><strong data-i18n="conclusion.effectiveness.point3.title">Practical value:</strong> <span data-i18n="conclusion.effectiveness.point3.desc">Provides a viable technical solution for handling ultra-long documents, code repositories, and other scenarios</span></li>
        </ul>
        
        <h4 data-i18n="conclusion.recommendation.title">Implementation Strategy Recommendations</h4>
        <p><strong style="color: #6f42c1;" data-i18n="conclusion.recommendation.stance">Based on these test results, maintaining the current flexible implementation approach is recommended</strong><span data-i18n="conclusion.recommendation.intro">, for the following reasons:</span></p>
        <ol>
            <li><strong data-i18n="conclusion.recommendation.point1.title">Significant performance differences:</strong> <span data-i18n="conclusion.recommendation.point1.desc">Performance differences between aggregation methods are substantial; forcing MEAN usage would severely damage some models' performance</span></li>
            <li><strong data-i18n="conclusion.recommendation.point2.title">Model diversity:</strong> <span data-i18n="conclusion.recommendation.point2.desc">Real applications encounter various native pooling types, requiring flexibility</span></li>
            <li><strong data-i18n="conclusion.recommendation.point3.title">User choice:</strong> <span data-i18n="conclusion.recommendation.point3.desc">Users should be allowed to choose the aggregation method most suitable for their models</span></li>
        </ol>
        
        <p><strong data-i18n="conclusion.recommendation.suggestion.title">Recommended approach:</strong> <span data-i18n="conclusion.recommendation.suggestion.desc">Maintain the current implementation that allows users to select aggregation strategies through configuration. Documentation should clearly indicate that for optimal performance, users should choose aggregation methods consistent with their model's native pooling type. This approach provides necessary flexibility while enabling optimal results across diverse model architectures.</span></p>
    </div>

    <div class="controls">
        <h3 data-i18n="controls.title">🔍 Performance Chart Viewer</h3>
        <p data-i18n="controls.description">Select model and pooling type to add to the performance chart:</p>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">
            <div class="control-group">
                <label for="modelSelect" data-i18n="controls.model.label">Model:</label>
                <select id="modelSelect">
                    <option value="" data-i18n="controls.model.placeholder">Select model</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="poolingSelect" data-i18n="controls.pooling.label">Pooling Type:</label>
                <select id="poolingSelect">
                    <option value="" data-i18n="controls.pooling.placeholder">Select pooling</option>
                    <option value="MEAN">MEAN</option>
                    <option value="LAST">LAST</option>
                    <option value="CLS">CLS</option>
                </select>
            </div>
        </div>
        
        <div style="display: flex; gap: 1rem; margin-top: 1rem; flex-wrap: wrap;">
            <button onclick="addToChart()" style="padding: 0.75rem 1.5rem; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 1rem;" data-i18n="controls.add.button">
                Add to Chart
            </button>
            <button onclick="clearChart()" style="padding: 0.75rem 1.5rem; background: #dc3545; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 1rem;" data-i18n="controls.clear.button">
                Clear Chart
            </button>
        </div>
        
        <div id="chartLegend" style="margin-top: 1rem; font-size: 0.9rem; line-height: 1.4;"></div>
    </div>

    <div id="detailResults" class="detail-results" style="display: block;">
        <h3 data-i18n="details.title">Performance Chart</h3>
        <div style="margin-bottom: 1rem;">
            <label data-i18n="chart.task.label">Task:</label>
            <select id="taskSelect" style="margin-left: 0.5rem; padding: 0.25rem;">
                <option value="LEMBNeedleRetrieval">LEMBNeedleRetrieval</option>
                <option value="LEMBPasskeyRetrieval">LEMBPasskeyRetrieval</option>
            </select>
        </div>
        <div style="position: relative; height: 500px;">
            <canvas id="performanceChart"></canvas>
        </div>
    </div>



    <script>
        // Language data for internationalization
        const i18nData = {
            en: {
                'page.title': 'vLLM Long Text Embedding Chunked Processing Test Results',
                'page.subtitle': 'Evaluating the performance of different pooling aggregation strategies in long text embedding tasks',
                'summary.title': '📊 Test Results Summary',
                'summary.description': 'Following PR reviewer recommendations, we tested three core models plus two additional Qwen models (supporting 32k context) to provide comprehensive analysis:',
                'summary.metrics.label': 'Evaluation Metrics:',
                'summary.metrics.description': 'Using ndcg_at_10 metric to measure model performance on LEMBNeedleRetrieval and LEMBPasskeyRetrieval tasks.',
                'highlight.title': 'Outstanding Performance: Qwen3-Embedding-4B Long Text Processing',
                'highlight.description': 'demonstrates exceptional long text processing capabilities under LAST pooling:',
                'highlight.score1': 'PasskeyRetrieval achieves',
                'highlight.score2': 'PasskeyRetrieval maintains',
                'highlight.score.unit': 'score',
                'highlight.conclusion': 'This proves that chunked processing technology can maintain excellent performance even when <strong>exceeding native 32k context limits</strong>!',
                'loading.text': 'Loading test results...',
                'controls.title': '🔍 Performance Chart Viewer',
                'controls.description': 'Select model and pooling type to add to the performance chart:',
                'controls.model.label': 'Model:',
                'controls.model.placeholder': 'Select model',
                'controls.pooling.label': 'Pooling Type:',
                'controls.pooling.placeholder': 'Select pooling',
                'controls.add.button': 'Add to Chart',
                'controls.clear.button': 'Clear Chart',
                'details.title': 'Performance Chart',
                'chart.task.label': 'Task:',
                'conclusion.title': '🎯 Key Findings and Conclusions',
                'conclusion.breakthrough.title': '🌟 Notable Achievement: Ultra-Long Text Processing Capability Validation',
                'conclusion.breakthrough.description': 'achieved <strong>excellent ultra-long text processing performance</strong> under LAST pooling: At extreme lengths of 34816 and 36864 tokens (exceeding the native 32k limit by 15%+), the PasskeyRetrieval task still maintains a <strong>near-perfect score of</strong>',
                'conclusion.breakthrough.suffix': ', providing strong performance validation for vLLM\'s chunked processing technology!',
                'conclusion.differences.title': 'Analysis of Pooling Strategy Performance in Chunked Processing',
                'conclusion.differences.intro': 'Contrary to the assumption that "mean pooling always performs better in chunked processing", our comprehensive test results reveal:',
                'conclusion.differences.point1.title': 'Native pooling types generally perform best:',
                'conclusion.differences.point1.desc': '4 out of 5 models achieved highest scores with their native pooling types',
                'conclusion.differences.point2.title': 'MEAN pooling is not a universal solution for chunked processing:',
                'conclusion.differences.point2.desc': 'For native LAST models, using LAST pooling strategy significantly outperforms MEAN pooling strategy',
                'conclusion.differences.point3.title': 'Interesting exception:',
                'conclusion.differences.point3.desc': 'Although ibm-granite model is natively CLS, MEAN pooling strategy performs best in chunked processing',
                'conclusion.effectiveness.title': 'Practical Effects of Chunked Processing',
                'conclusion.effectiveness.intro': 'Ultra-long text testing of Qwen models (34816, 36864 tokens) proves the effectiveness of chunked processing:',
                'conclusion.effectiveness.point1.title': '🌟 Qwen3-Embedding-4B shows outstanding performance:',
                'conclusion.effectiveness.point1.desc': 'Under LAST pooling strategy in chunked processing, even exceeding the native 32k context limit, PasskeyRetrieval task still maintains a high score of',
                'conclusion.effectiveness.point1.suffix': '',
                'conclusion.effectiveness.point2.title': 'Technical validation:',
                'conclusion.effectiveness.point2.desc': 'This is the first proof that chunked processing technology can maintain near-native performance on ultra-long texts',
                'conclusion.effectiveness.point3.title': 'Practical value:',
                'conclusion.effectiveness.point3.desc': 'Provides a viable technical solution for handling ultra-long documents, code repositories, and other scenarios',
                'conclusion.recommendation.title': 'Implementation Strategy Recommendations',
                'conclusion.recommendation.stance': 'Based on these test results, maintaining the current flexible implementation approach is recommended',
                'conclusion.recommendation.intro': ', for the following reasons:',
                'conclusion.recommendation.point1.title': 'Significant performance differences:',
                'conclusion.recommendation.point1.desc': 'Performance differences between pooling strategies in chunked processing are substantial; forcing MEAN usage would severely damage some models\' performance',
                'conclusion.recommendation.point2.title': 'Model diversity:',
                'conclusion.recommendation.point2.desc': 'Real applications encounter various native pooling types, requiring flexibility',
                'conclusion.recommendation.point3.title': 'User choice:',
                'conclusion.recommendation.point3.desc': 'Users should be allowed to choose the pooling strategy most suitable for their models in chunked processing',
                'conclusion.recommendation.suggestion.title': 'Recommended approach:',
                'conclusion.recommendation.suggestion.desc': 'Maintain the current implementation that allows users to select pooling strategies for chunked processing through configuration. Documentation should clearly indicate that for optimal performance, users should choose pooling strategies consistent with their model\'s native pooling type. This approach provides necessary flexibility while enabling optimal results across diverse model architectures.',
                'model.native': 'native',
                'model.pooling': ' pooling',
                'model.data.missing': 'Data Missing',
                'model.excellent.long': '⚡Excellent Long Text',
                'details.select.complete': 'Please select model and pooling type',
                'highlight.chart.title': 'Performance Chart: Ultra-Long Text Processing',
                'highlight.chart.note': '32k context limit highlighted in red dashed line',
                'highlight.chart.qwen.title': 'Qwen3-Embedding-4B (LAST Pooling) - Ultra-Long Text Performance'
            },
            zh: {
                'page.title': 'vLLM长文本嵌入分片处理测试结果',
                'page.subtitle': '评估不同pooling聚合策略在长文本嵌入任务中的性能表现',
                'summary.title': '📊 测试结果汇总',
                'summary.description': '根据PR审核员建议，我们测试了三个核心模型，同时包含了两个额外的Qwen模型（支持32k上下文）以提供全面的分析：',
                'summary.metrics.label': '评估指标：',
                'summary.metrics.description': '使用 ndcg_at_10 指标衡量模型性能，分别在 LEMBNeedleRetrieval 和 LEMBPasskeyRetrieval 任务上进行测试。',
                'highlight.title': '突出表现：Qwen3-Embedding-4B超长文本处理',
                'highlight.description': '在LAST pooling下展现了卓越的超长文本处理能力：',
                'highlight.score1': 'PasskeyRetrieval达到',
                'highlight.score2': 'PasskeyRetrieval维持',
                'highlight.score.unit': '分',
                'highlight.conclusion': '这证明了分片处理技术在<strong>超出原生32k上下文限制</strong>时仍能保持优异性能！',
                'loading.text': '正在加载测试结果...',
                'controls.title': '🔍 性能图表查看器',
                'controls.description': '选择模型和pooling类型添加到性能图表中：',
                'controls.model.label': '模型：',
                'controls.model.placeholder': '请选择模型',
                'controls.pooling.label': 'Pooling类型：',
                'controls.pooling.placeholder': '请选择Pooling',
                'controls.add.button': '添加到图表',
                'controls.clear.button': '清空图表',
                'details.title': '性能图表',
                'chart.task.label': '任务：',
                'conclusion.title': '🎯 关键发现与结论',
                'conclusion.breakthrough.title': '🌟 显著成果：超长文本处理能力验证',
                'conclusion.breakthrough.description': '在LAST pooling下实现了<strong>优异的超长文本处理性能</strong>：在34816和36864 tokens（超出32k原生限制15%+）的极端长度下，PasskeyRetrieval任务仍维持<strong>',
                'conclusion.breakthrough.suffix': '的近完美分数</strong>，这为vLLM的分片处理技术提供了强有力的性能验证！',
                'conclusion.differences.title': '分片处理中池化策略性能分析',
                'conclusion.differences.intro': '与"分片处理中mean pooling总是表现更好"的假设相反，我们的全面测试结果表明：',
                'conclusion.differences.point1.title': '原生pooling类型普遍表现最佳：',
                'conclusion.differences.point1.desc': '5个模型中有4个在原生pooling类型下获得最高分数',
                'conclusion.differences.point2.title': 'MEAN pooling并非分片处理的万能解决方案：',
                'conclusion.differences.point2.desc': '对于原生LAST模型，使用LAST pooling策略显著优于MEAN pooling策略',
                'conclusion.differences.point3.title': '有趣的例外：',
                'conclusion.differences.point3.desc': 'ibm-granite模型虽然原生是CLS，但在分片处理中MEAN pooling策略表现最好',
                'conclusion.effectiveness.title': '分片处理的实际效果',
                'conclusion.effectiveness.intro': 'Qwen模型的超长文本测试（34816、36864 tokens）证明了分片处理的有效性：',
                'conclusion.effectiveness.point1.title': '🌟 Qwen3-Embedding-4B表现突出：',
                'conclusion.effectiveness.point1.desc': '在分片处理的LAST pooling策略下，即使超出原生32k上下文限制，PasskeyRetrieval任务仍保持',
                'conclusion.effectiveness.point1.suffix': '的高分',
                'conclusion.effectiveness.point2.title': '技术验证：',
                'conclusion.effectiveness.point2.desc': '这是首次证明分片处理技术能在超长文本上维持接近原生性能',
                'conclusion.effectiveness.point3.title': '实用价值：',
                'conclusion.effectiveness.point3.desc': '为处理超长文档、代码库等场景提供了可行的技术方案',
                'conclusion.recommendation.title': '实现策略建议',
                'conclusion.recommendation.stance': '基于测试结果，建议保持当前灵活的实现方式',
                'conclusion.recommendation.intro': '，原因如下：',
                'conclusion.recommendation.point1.title': '性能差异显著：',
                'conclusion.recommendation.point1.desc': '分片处理中不同pooling策略的性能差异很大，强制使用MEAN会严重损害某些模型的性能',
                'conclusion.recommendation.point2.title': '模型多样性：',
                'conclusion.recommendation.point2.desc': '实际应用中会遇到各种原生pooling类型的模型，需要保持灵活性',
                'conclusion.recommendation.point3.title': '用户选择权：',
                'conclusion.recommendation.point3.desc': '应该让用户选择最适合其模型的分片处理pooling策略',
                'conclusion.recommendation.suggestion.title': '建议方案：',
                'conclusion.recommendation.suggestion.desc': '保持当前允许用户通过配置选择分片处理pooling策略的实现方式。文档应明确说明，为获得最佳性能，用户应选择与其模型原生pooling类型一致的pooling策略。这种方法在提供必要灵活性的同时，能够在多样化的模型架构上实现最优结果。',
                'model.native': '原生',
                'model.pooling': 'pooling',
                'model.data.missing': '数据缺失',
                'model.excellent.long': '⚡超长文本优异',
                'details.select.complete': '请选择模型和Pooling类型',
                'highlight.chart.title': '性能图表：超长文本处理',
                'highlight.chart.note': '红色虚线标示32k上下文限制',
                'highlight.chart.qwen.title': 'Qwen3-Embedding-4B (LAST Pooling) - 超长文本性能表现'
            }
        };

        // Current language (default to English)
        let currentLanguage = 'en';

        // Language switching function
        function switchLanguage(lang) {
            currentLanguage = lang;
            document.documentElement.lang = lang;
            document.title = i18nData[lang]['page.title'];
            
            // Update language buttons
            document.querySelectorAll('.language-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent === (lang === 'en' ? 'EN' : '中文')) {
                    btn.classList.add('active');
                }
            });
            
            // Update all text elements with data-i18n attributes
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (i18nData[lang][key]) {
                    element.innerHTML = i18nData[lang][key];
                }
            });
            
            // Reload model results to update dynamic content
            loadAllResults();
            
            // Update chart legend if chart exists
            if (typeof updateChartLegend === 'function') {
                updateChartLegend();
            }
            
            // Update Qwen chart language
            updateQwenChartLanguage();
        }

        // Helper function to get translated text
        function t(key) {
            return i18nData[currentLanguage][key] || key;
        }

        // Get Qwen chart title based on current language
        function getQwenChartTitle() {
            return t('highlight.chart.qwen.title');
        }

        // Update Qwen chart language
        function updateQwenChartLanguage() {
            if (qwenChart) {
                qwenChart.options.plugins.title.text = getQwenChartTitle();
                qwenChart.update();
            }
        }

        // 模型配置信息
        const modelConfigs = {
            'BAAI_bge-multilingual-gemma2': {
                name: 'BAAI/bge-multilingual-gemma2',
                nativePooling: 'LAST',
                context: '8k',
                path: 'BAAI/bge-multilingual-gemma2_None-0_openai_local'
            },
            'intfloat_multilingual-e5-large': {
                name: 'intfloat/multilingual-e5-large',
                nativePooling: 'MEAN',
                context: '514',
                path: 'intfloat/multilingual-e5-large_None-0_openai_local'
            },
            'ibm-granite_granite-embedding-278m-multilingual': {
                name: 'ibm-granite/granite-embedding-278m-multilingual',
                nativePooling: 'CLS',
                context: '514',
                path: 'ibm-granite/granite-embedding-278m-multilingual_None-0_openai_local'
            },
            'Qwen_Qwen3-Embedding-0.6B': {
                name: 'Qwen/Qwen3-Embedding-0.6B',
                nativePooling: 'LAST',
                context: '32k',
                path: 'Qwen/Qwen3-Embedding-0.6B_None-0_openai_local'
            },
            'Qwen_Qwen3-Embedding-4B': {
                name: 'Qwen/Qwen3-Embedding-4B',
                nativePooling: 'LAST',
                context: '32k',
                path: 'Qwen/Qwen3-Embedding-4B_None-0_openai_local'
            }
        };

        // 加载所有模型的overall_results
        async function loadAllResults() {
            const modelResultsDiv = document.getElementById('modelResults');
            modelResultsDiv.innerHTML = '';
            
            const modelSelect = document.getElementById('modelSelect');
            modelSelect.innerHTML = `<option value="">${t('controls.model.placeholder')}</option>`;

            for (const [modelKey, config] of Object.entries(modelConfigs)) {
                // 添加到选择框
                const option = document.createElement('option');
                option.value = modelKey;
                option.text = config.name;
                modelSelect.appendChild(option);

                // 创建模型卡片
                const modelCard = document.createElement('div');
                modelCard.className = 'model-card';
                
                let cardHTML = `
                    <div class="model-title">
                        ${config.name} 
                        <span style="font-size: 0.8rem; color: #666;">
                            (${t('model.native')}${config.nativePooling} pooling, ${config.context} context)
                        </span>
                    </div>
                `;

                const poolingTypes = ['MEAN', 'LAST', 'CLS'];
                const results = {};
                
                // 加载各种pooling类型的结果
                for (const pooling of poolingTypes) {
                    try {
                        let pathSuffix = '';
                        if (pooling === 'LAST') {
                            pathSuffix = '_pool_last';
                        } else if (pooling === 'CLS') {
                            pathSuffix = '_pool_cls';
                        }
                        // 原生MEAN不需要后缀，其他情况都需要后缀
                        
                        const url = `results/vllm_original_length/${pooling}/${modelKey}/${config.path}${pathSuffix}/overall_results.json`;
                        const response = await fetch(url);
                        
                        if (response.ok) {
                            const data = await response.json();
                            results[pooling] = data;
                        } else {
                            console.warn(`Failed to load ${url}`);
                        }
                    } catch (error) {
                        console.warn(`Error loading ${pooling} results for ${modelKey}:`, error);
                    }
                }
                
                // 找出最佳性能的pooling类型
                let bestPooling = config.nativePooling;
                let bestScore = 0;
                
                for (const [pooling, data] of Object.entries(results)) {
                    if (data && data.LEMBNeedleRetrieval && data.LEMBPasskeyRetrieval) {
                        const avgScore = (data.LEMBNeedleRetrieval.avg + data.LEMBPasskeyRetrieval.avg) / 2;
                        if (avgScore > bestScore) {
                            bestScore = avgScore;
                            bestPooling = pooling;
                        }
                    }
                }
                
                // 显示结果
                for (const pooling of poolingTypes) {
                    const data = results[pooling];
                    const isBest = pooling === bestPooling;
                    const isNative = pooling === config.nativePooling;
                    
                    if (data && data.LEMBNeedleRetrieval && data.LEMBPasskeyRetrieval) {
                        const needleScore = data.LEMBNeedleRetrieval.avg.toFixed(4);
                        const passkeyScore = data.LEMBPasskeyRetrieval.avg.toFixed(4);
                        
                        // 特别标注Qwen3-Embedding-4B在LAST pooling下的超长文本表现
                        let specialNote = '';
                        if (modelKey === 'Qwen_Qwen3-Embedding-4B' && pooling === 'LAST') {
                            specialNote = ` <span style="color: #28a745; font-size: 0.8rem;">${t('model.excellent.long')}</span>`;
                        }
                        
                        cardHTML += `
                            <div class="pooling-result ${isBest ? 'best' : 'normal'}">
                                <span>
                                    ${isBest ? '🏆 ' : ''}
                                    <strong>${pooling}${t('model.pooling')}${isNative ? ` (${t('model.native')})` : ''}</strong>${specialNote}
                                </span>
                                <span class="score">${needleScore}/${passkeyScore}</span>
                            </div>
                        `;
                    } else {
                        cardHTML += `
                            <div class="pooling-result normal">
                                <span><strong>${pooling}${t('model.pooling')}${isNative ? ` (${t('model.native')})` : ''}</strong></span>
                                <span class="score" style="color: #999;">${t('model.data.missing')}</span>
                            </div>
                        `;
                    }
                }

                modelCard.innerHTML = cardHTML;
                modelResultsDiv.appendChild(modelCard);
            }
        }

        // Chart instance
        let performanceChart = null;
        let chartDatasets = [];
        let qwenChart = null;
        
        // Initialize chart
        function initChart() {
            const ctx = document.getElementById('performanceChart').getContext('2d');
            performanceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Performance Comparison (ndcg_at_10)'
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Context Length (tokens)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'ndcg_at_10 Score'
                            },
                            min: 0,
                            max: 1
                        }
                    },
                    elements: {
                        line: {
                            tension: 0.1
                        },
                        point: {
                            radius: 4,
                            hoverRadius: 6
                        }
                    }
                }
            });
            
            // Update chart when task selection changes
            document.getElementById('taskSelect').addEventListener('change', updateChartData);
        }

        // Initialize Qwen3-Embedding-4B performance chart
        async function initQwenChart() {
            const ctx = document.getElementById('qwenPerformanceChart').getContext('2d');
            
            try {
                // Load Qwen3-Embedding-4B LAST pooling data
                const response = await fetch('results/vllm_original_length/LAST/Qwen_Qwen3-Embedding-4B/Qwen/Qwen3-Embedding-4B_None-0_openai_local_pool_last/overall_results.json');
                
                if (!response.ok) {
                    throw new Error('Failed to load data');
                }
                
                const data = await response.json();
                
                // Context lengths including ultra-long ones
                const contexts = ['256', '512', '1024', '2048', '4096', '8192', '16384', '32768', '34816', '36864'];
                const contextNumbers = contexts.map(c => parseInt(c));
                
                // Prepare data for both tasks
                const needleData = contexts.map(context => 
                    data.LEMBNeedleRetrieval && data.LEMBNeedleRetrieval[context] !== undefined 
                        ? data.LEMBNeedleRetrieval[context] 
                        : null
                );
                
                const passkeyData = contexts.map(context => 
                    data.LEMBPasskeyRetrieval && data.LEMBPasskeyRetrieval[context] !== undefined 
                        ? data.LEMBPasskeyRetrieval[context] 
                        : null
                );
                
                qwenChart = new Chart(ctx, {
                    type: 'line',
                    plugins: [window['chartjs-plugin-annotation']],
                    data: {
                        labels: contexts,
                        datasets: [
                            {
                                label: 'LEMBNeedleRetrieval',
                                data: needleData,
                                borderColor: '#28a745',
                                backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                borderWidth: 3,
                                fill: false,
                                tension: 0.1,
                                pointRadius: 5,
                                pointHoverRadius: 7
                            },
                            {
                                label: 'LEMBPasskeyRetrieval',
                                data: passkeyData,
                                borderColor: '#20c997',
                                backgroundColor: 'rgba(32, 201, 151, 0.1)',
                                borderWidth: 3,
                                fill: false,
                                tension: 0.1,
                                pointRadius: 5,
                                pointHoverRadius: 7
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: getQwenChartTitle(),
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            annotation: {
                                annotations: {
                                    line1: {
                                        type: 'line',
                                        xMin: 7,  // Index of 32768 in contexts array
                                        xMax: 7,
                                        borderColor: '#dc3545',
                                        borderWidth: 2,
                                        borderDash: [5, 5],
                                        label: {
                                            content: '32k Limit',
                                            enabled: true,
                                            position: 'end'
                                        }
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Context Length (tokens)',
                                    font: {
                                        weight: 'bold'
                                    }
                                },
                                ticks: {
                                    callback: function(value, index) {
                                        const label = this.getLabelForValue(value);
                                        const num = parseInt(label);
                                        // Highlight ultra-long contexts
                                        return num > 32768 ? `${label}*` : label;
                                    }
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'ndcg_at_10 Score',
                                    font: {
                                        weight: 'bold'
                                    }
                                },
                                min: 0,
                                max: 1.0,
                                ticks: {
                                    stepSize: 0.1
                                }
                            }
                        },
                        elements: {
                            line: {
                                tension: 0.1
                            },
                            point: {
                                pointStyle: function(ctx) {
                                    const index = ctx.dataIndex;
                                    const value = parseInt(contexts[index]);
                                    // Use different point style for ultra-long contexts
                                    return value > 32768 ? 'rectRot' : 'circle';
                                }
                            }
                        }
                    }
                });
                
            } catch (error) {
                console.error('Error loading Qwen chart data:', error);
                // Show error message in chart
                ctx.fillStyle = '#666';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Failed to load performance data', ctx.canvas.width / 2, ctx.canvas.height / 2);
            }
        }

        // Add model to chart
        async function addToChart() {
            const modelKey = document.getElementById('modelSelect').value;
            const pooling = document.getElementById('poolingSelect').value;
            
            if (!modelKey || !pooling) {
                alert(t('details.select.complete').replace('完整的配置信息', '模型和Pooling类型').replace('complete configuration information', 'model and pooling type'));
                return;
            }
            
            // Check if this combination already exists
            const datasetLabel = `${modelConfigs[modelKey].name} (${pooling})`;
            if (chartDatasets.find(d => d.label === datasetLabel)) {
                alert(currentLanguage === 'zh' ? '该模型组合已存在' : 'This model combination already exists');
                return;
            }
            
            try {
                const config = modelConfigs[modelKey];
                let pathSuffix = '';
                
                if (pooling === 'LAST') {
                    pathSuffix = '_pool_last';
                } else if (pooling === 'CLS') {
                    pathSuffix = '_pool_cls';
                }
                
                // Load overall results
                const url = `results/vllm_original_length/${pooling}/${modelKey}/${config.path}${pathSuffix}/overall_results.json`;
                const response = await fetch(url);
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Get context lengths and sort them numerically
                    const contexts = ['256', '512', '1024', '2048', '4096', '8192', '16384', '32768'];
                    if (modelKey.includes('Qwen')) {
                        contexts.push('34816', '36864');
                    }
                    
                    // Generate random color for this dataset
                    const colors = [
                        '#667eea', '#f093fb', '#4facfe', '#43e97b', '#fa709a',
                        '#ffecd2', '#fcb69f', '#a8edea', '#fed6e3', '#d299c2'
                    ];
                    const color = colors[chartDatasets.length % colors.length];
                    
                    // Create dataset
                    const dataset = {
                        label: datasetLabel,
                        data: [],
                        borderColor: color,
                        backgroundColor: color + '20',
                        borderWidth: 2,
                        fill: false
                    };
                    
                    // Add to datasets
                    chartDatasets.push({
                        ...dataset,
                        rawData: data,
                        modelKey,
                        pooling,
                        contexts: contexts
                    });
                    
                    // Update chart labels if needed
                    if (performanceChart.data.labels.length === 0) {
                        performanceChart.data.labels = contexts;
                    }
                    
                    // Update chart data
                    updateChartData();
                    updateChartLegend();
                    
                } else {
                    alert(currentLanguage === 'zh' ? '无法加载数据' : 'Failed to load data');
                }
            } catch (error) {
                alert(`${currentLanguage === 'zh' ? '加载错误: ' : 'Loading error: '}${error.message}`);
            }
        }
        
        // Update chart data based on selected task
        function updateChartData() {
            if (!performanceChart || chartDatasets.length === 0) return;
            
            const selectedTask = document.getElementById('taskSelect').value;
            
            performanceChart.data.datasets = chartDatasets.map(dataset => {
                const data = [];
                dataset.contexts.forEach(context => {
                    if (dataset.rawData[selectedTask] && dataset.rawData[selectedTask][context] !== undefined) {
                        data.push(dataset.rawData[selectedTask][context]);
                    } else {
                        data.push(null);
                    }
                });
                
                return {
                    ...dataset,
                    data: data
                };
            });
            
            performanceChart.options.plugins.title.text = `${selectedTask} Performance Comparison (ndcg_at_10)`;
            performanceChart.update();
        }
        
        // Clear chart
        function clearChart() {
            chartDatasets = [];
            if (performanceChart) {
                performanceChart.data.datasets = [];
                performanceChart.data.labels = [];
                performanceChart.update();
            }
            updateChartLegend();
        }
        
        // Update chart legend
        function updateChartLegend() {
            const legendDiv = document.getElementById('chartLegend');
            if (chartDatasets.length === 0) {
                legendDiv.innerHTML = `<em>${currentLanguage === 'zh' ? '选择模型和Pooling类型开始对比' : 'Select model and pooling type to start comparison'}</em>`;
            } else {
                const legendItems = chartDatasets.map((dataset, index) => {
                    const config = modelConfigs[dataset.modelKey];
                    const isNative = config.nativePooling === dataset.pooling;
                    return `<span style="color: ${dataset.borderColor}; font-weight: bold;">●</span> ${dataset.label}${isNative ? ` (${t('model.native')})` : ''}`;
                }).join(' | ');
                legendDiv.innerHTML = `<strong>${currentLanguage === 'zh' ? '图表中的模型:' : 'Models in chart:'}</strong> ${legendItems}`;
            }
        }



        // Load Qwen3-Embedding-4B highlight scores
        async function loadQwenHighlightScores() {
            try {
                const response = await fetch('results/vllm_original_length/LAST/Qwen_Qwen3-Embedding-4B/Qwen/Qwen3-Embedding-4B_None-0_openai_local_pool_last/overall_results.json');
                if (response.ok) {
                    const data = await response.json();
                    
                    // Update individual scores
                    const score34816 = data.LEMBPasskeyRetrieval['34816'];
                    const score36864 = data.LEMBPasskeyRetrieval['36864'];
                    
                    if (score34816 !== undefined) {
                        document.getElementById('score-34816').textContent = score34816;
                    }
                    if (score36864 !== undefined) {
                        document.getElementById('score-36864').textContent = score36864;
                    }
                    
                    // Update conclusion scores (use average of ultra-long scores for representative value)
                    if (score34816 !== undefined && score36864 !== undefined) {
                        const representativeScore = score34816; // In this case both are 0.98, but we could use average
                        document.getElementById('conclusion-score').textContent = representativeScore;
                        document.getElementById('effectiveness-score').textContent = representativeScore;
                    } else if (score34816 !== undefined) {
                        document.getElementById('conclusion-score').textContent = score34816;
                        document.getElementById('effectiveness-score').textContent = score34816;
                    } else if (score36864 !== undefined) {
                        document.getElementById('conclusion-score').textContent = score36864;
                        document.getElementById('effectiveness-score').textContent = score36864;
                    }
                } else {
                    console.warn('Failed to load Qwen highlight scores');
                    // Set fallback values
                    document.getElementById('score-34816').textContent = 'N/A';
                    document.getElementById('score-36864').textContent = 'N/A';
                    document.getElementById('conclusion-score').textContent = 'N/A';
                    document.getElementById('effectiveness-score').textContent = 'N/A';
                }
            } catch (error) {
                console.error('Error loading Qwen highlight scores:', error);
                // Set fallback values
                document.getElementById('score-34816').textContent = 'N/A';
                document.getElementById('score-36864').textContent = 'N/A';
                document.getElementById('conclusion-score').textContent = 'N/A';
                document.getElementById('effectiveness-score').textContent = 'N/A';
            }
        }

        // 页面加载时初始化
        window.addEventListener('load', function() {
            // Initialize with English language
            switchLanguage('en');
            // Load dynamic highlight scores
            loadQwenHighlightScores();
            // Initialize chart
            initChart();
            // Initialize chart legend
            updateChartLegend();
            // Initialize Qwen performance chart
            initQwenChart();
        });
    </script>
</body>
</html> 