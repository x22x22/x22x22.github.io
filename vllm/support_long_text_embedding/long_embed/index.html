<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vLLM Long Text Embedding Chunked Processing Test Results</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            background-color: #f8f9fa;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem;
            border-radius: 10px;
            margin-bottom: 2rem;
            text-align: center;
        }
        
        .summary {
            background: white;
            padding: 2rem;
            border-radius: 10px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .model-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin: 2rem 0;
        }
        
        .model-card {
            background: white;
            border-radius: 10px;
            padding: 1.5rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-left: 4px solid #667eea;
        }
        
        .model-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: #333;
        }
        
        .pooling-result {
            margin: 0.5rem 0;
            padding: 0.5rem;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .pooling-result.best {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            font-weight: bold;
        }
        
        .pooling-result.normal {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
        }
        
        .score {
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        
        .controls {
            background: white;
            padding: 1.5rem;
            border-radius: 10px;
            margin: 2rem 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .control-group {
            margin: 1rem 0;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
        }
        
        .control-group select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }
        
        .detail-results {
            background: white;
            padding: 2rem;
            border-radius: 10px;
            margin: 2rem 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: none;
        }
        
        .metrics-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }
        
        .metrics-table th,
        .metrics-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        .metrics-table th {
            background-color: #f8f9fa;
            font-weight: bold;
        }
        
        .metrics-table tr:hover {
            background-color: #f5f5f5;
        }
        
        .loading {
            text-align: center;
            padding: 2rem;
            color: #666;
        }
        
        .error {
            color: #dc3545;
            padding: 1rem;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 5px;
            margin: 1rem 0;
        }
        
        .highlight {
            background-color: #fff3cd;
            padding: 1rem;
            border-left: 4px solid #ffc107;
            margin: 1rem 0;
        }
        
        .conclusion {
            background: white;
            color: #333;
            padding: 2rem;
            border-radius: 10px;
            margin: 2rem 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-left: 4px solid #6f42c1;
        }
        
        .conclusion h3 {
            color: #6f42c1;
            margin-top: 0;
        }
        
        .language-switcher {
            position: fixed;
            top: 20px;
            right: max(20px, calc((100vw - 1400px) / 2 + 20px));
            z-index: 1000;
            display: flex;
            gap: 10px;
        }
        
        @media (max-width: 1440px) {
            .language-switcher {
                right: 20px;
            }
        }
        
        .language-btn {
            padding: 8px 16px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .language-btn:hover {
            background: #667eea;
            color: white;
        }
        
        .language-btn.active {
            background: #667eea;
            color: white;
        }
    </style>
  </head>
<body>
    <div class="language-switcher">
        <button class="language-btn active" onclick="switchLanguage('en')">EN</button>
        <button class="language-btn" onclick="switchLanguage('zh')">ä¸­æ–‡</button>
    </div>
    
    <div class="header">
        <h1 data-i18n="page.title">vLLM Long Text Embedding Chunked Processing Test Results</h1>
        <p data-i18n="page.subtitle">Evaluating the performance of different pooling aggregation strategies in long text embedding tasks</p>
    </div>

    <div class="summary">
        <h2 data-i18n="summary.title">ğŸ“Š Test Results Summary</h2>
        <p data-i18n="summary.description">Following the PR reviewer's recommendations, we tested three core models, plus two additional Qwen models (supporting 32k context) for result analysis:</p>
        
        <div class="highlight">
            <strong data-i18n="summary.metrics.label">Evaluation Metrics:</strong> <span data-i18n="summary.metrics.description">Using ndcg_at_10 metric to measure model performance on LEMBNeedleRetrieval and LEMBPasskeyRetrieval tasks.</span>
        </div>

        <div style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; padding: 1.5rem; border-radius: 10px; margin: 1rem 0;">
            <h4 style="margin-top: 0; display: flex; align-items: center;">
                ğŸŒŸ <span style="margin-left: 0.5rem;" data-i18n="highlight.title">Outstanding Performance: Qwen3-Embedding-4B Long Text Processing</span>
            </h4>
            <p style="margin-bottom: 1rem;">
                <strong>Qwen3-Embedding-4B</strong> <span data-i18n="highlight.description">demonstrates exceptional long text processing capabilities under LAST pooling:</span>
                <br>â€¢ <strong>34816 tokens</strong>: <span data-i18n="highlight.score1">PasskeyRetrieval achieves</span> <strong id="score-34816">--</strong> <span data-i18n="highlight.score.unit">score</span>
                <br>â€¢ <strong>36864 tokens</strong>: <span data-i18n="highlight.score2">PasskeyRetrieval maintains</span> <strong id="score-36864">--</strong> <span data-i18n="highlight.score.unit">score</span>
                <br>â€¢ <span data-i18n="highlight.conclusion">This proves that chunked processing technology can maintain excellent performance even when <strong>exceeding native 32k context limits</strong>!</span>
            </p>
            
            <!-- æ·»åŠ ä¸“é—¨çš„Qwen3-Embedding-4Bæ€§èƒ½å›¾è¡¨ -->
            <div style="background: rgba(255,255,255,0.15); border-radius: 8px; padding: 1rem; margin-top: 1rem;">
                <h5 style="margin-top: 0; margin-bottom: 1rem;" data-i18n="highlight.chart.title">Performance Chart: Ultra-Long Text Processing</h5>
                <div style="background: white; border-radius: 6px; padding: 1rem;">
                    <div style="position: relative; height: 300px;">
                        <canvas id="qwenPerformanceChart"></canvas>
                    </div>
                    <div style="margin-top: 0.5rem; font-size: 0.85rem; color: #666; text-align: center;">
                        <span data-i18n="highlight.chart.note">32k context limit highlighted in red dashed line</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="modelResults" class="model-grid">
            <div class="loading" data-i18n="loading.text">Loading test results...</div>
        </div>
    </div>

    <div class="conclusion">
        <h3 data-i18n="conclusion.title">ğŸ¯ Key Findings and Conclusions</h3>
        
        <div style="background: rgba(40, 167, 69, 0.1); border: 2px solid #28a745; border-radius: 8px; padding: 1rem; margin: 1rem 0;">
            <h4 style="color: #28a745; margin-top: 0;" data-i18n="conclusion.breakthrough.title">ğŸŒŸ Notable Achievement: Ultra-Long Text Processing Capability Validation</h4>
            <p style="margin-bottom: 0;">
                <strong>Qwen3-Embedding-4B</strong> <span data-i18n="conclusion.breakthrough.description">achieved <strong>excellent ultra-long text processing performance</strong> under LAST pooling: At extreme lengths of 34816 and 36864 tokens (exceeding the native 32k limit by 15%+), the PasskeyRetrieval task still maintains a <strong>near-perfect score of</strong></span> <strong id="conclusion-score">--</strong><span data-i18n="conclusion.breakthrough.suffix">, providing strong performance validation for vLLM's chunked processing technology!</span>
            </p>
        </div>
        
        <h4 data-i18n="conclusion.differences.title">Analysis of Aggregation Strategy Performance</h4>
        <p data-i18n="conclusion.differences.intro">Contrary to the assumption that "mean aggregation always performs better", our comprehensive test results reveal:</p>
        <ul>
            <li><strong data-i18n="conclusion.differences.point1.title">Native pooling types generally perform best:</strong> <span data-i18n="conclusion.differences.point1.desc">4 out of 5 models achieved highest scores with their native pooling types</span></li>
            <li><strong data-i18n="conclusion.differences.point2.title">MEAN aggregation is not a universal solution:</strong> <span data-i18n="conclusion.differences.point2.desc">For native LAST models, LAST aggregation significantly outperforms MEAN aggregation</span></li>
            <li><strong data-i18n="conclusion.differences.point3.title">Interesting exception:</strong> <span data-i18n="conclusion.differences.point3.desc">Although ibm-granite model is natively CLS, MEAN aggregation performs best</span></li>
        </ul>
        
        <h4 data-i18n="conclusion.effectiveness.title">Practical Effects of Chunked Processing</h4>
        <p data-i18n="conclusion.effectiveness.intro">Ultra-long text testing of Qwen models (34816, 36864 tokens) proves the effectiveness of chunked processing:</p>
        <ul>
            <li><strong data-i18n="conclusion.effectiveness.point1.title">ğŸŒŸ Qwen3-Embedding-4B shows outstanding performance:</strong> <span data-i18n="conclusion.effectiveness.point1.desc">Under LAST aggregation, even exceeding the native 32k context limit, PasskeyRetrieval task still maintains a high score of</span> <strong id="effectiveness-score">--</strong><span data-i18n="conclusion.effectiveness.point1.suffix"></span></li>
            <li><strong data-i18n="conclusion.effectiveness.point2.title">Technical validation:</strong> <span data-i18n="conclusion.effectiveness.point2.desc">This is the first proof that chunked processing technology can maintain near-native performance on ultra-long texts</span></li>
            <li><strong data-i18n="conclusion.effectiveness.point3.title">Practical value:</strong> <span data-i18n="conclusion.effectiveness.point3.desc">Provides a viable technical solution for handling ultra-long documents, code repositories, and other scenarios</span></li>
        </ul>
        
        <h4 data-i18n="conclusion.recommendation.title">Implementation Strategy Recommendations</h4>
        <p><strong style="color: #6f42c1;" data-i18n="conclusion.recommendation.stance">Based on these test results, maintaining the current flexible implementation approach is recommended</strong><span data-i18n="conclusion.recommendation.intro">, for the following reasons:</span></p>
        <ol>
            <li><strong data-i18n="conclusion.recommendation.point1.title">Significant performance differences:</strong> <span data-i18n="conclusion.recommendation.point1.desc">Performance differences between aggregation methods are substantial; forcing MEAN usage would severely damage some models' performance</span></li>
            <li><strong data-i18n="conclusion.recommendation.point2.title">Model diversity:</strong> <span data-i18n="conclusion.recommendation.point2.desc">Real applications encounter various native pooling types, requiring flexibility</span></li>
            <li><strong data-i18n="conclusion.recommendation.point3.title">User choice:</strong> <span data-i18n="conclusion.recommendation.point3.desc">Users should be allowed to choose the aggregation method most suitable for their models</span></li>
        </ol>
        
        <p><strong data-i18n="conclusion.recommendation.suggestion.title">Recommended approach:</strong> <span data-i18n="conclusion.recommendation.suggestion.desc">Maintain the current implementation that allows users to select aggregation strategies through configuration. Documentation should clearly indicate that for optimal performance, users should choose aggregation methods consistent with their model's native pooling type. This approach provides necessary flexibility while enabling optimal results across diverse model architectures.</span></p>
    </div>

    <div class="controls">
        <h3 data-i18n="controls.title">ğŸ” Performance Chart Viewer</h3>
        <p data-i18n="controls.description">Select model and pooling type to add to the performance chart:</p>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">
            <div class="control-group">
                <label for="modelSelect" data-i18n="controls.model.label">Model:</label>
                <select id="modelSelect">
                    <option value="" data-i18n="controls.model.placeholder">Select model</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="poolingSelect" data-i18n="controls.pooling.label">Pooling Type:</label>
                <select id="poolingSelect">
                    <option value="" data-i18n="controls.pooling.placeholder">Select pooling</option>
                    <option value="MEAN">MEAN</option>
                    <option value="LAST">LAST</option>
                    <option value="CLS">CLS</option>
                </select>
            </div>
        </div>
        
        <div style="display: flex; gap: 1rem; margin-top: 1rem; flex-wrap: wrap;">
            <button onclick="addToChart()" style="padding: 0.75rem 1.5rem; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 1rem;" data-i18n="controls.add.button">
                Add to Chart
            </button>
            <button onclick="clearChart()" style="padding: 0.75rem 1.5rem; background: #dc3545; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 1rem;" data-i18n="controls.clear.button">
                Clear Chart
            </button>
        </div>
        
        <div id="chartLegend" style="margin-top: 1rem; font-size: 0.9rem; line-height: 1.4;"></div>
    </div>

    <div id="detailResults" class="detail-results" style="display: block;">
        <h3 data-i18n="details.title">Performance Chart</h3>
        <div style="margin-bottom: 1rem;">
            <label data-i18n="chart.task.label">Task:</label>
            <select id="taskSelect" style="margin-left: 0.5rem; padding: 0.25rem;">
                <option value="LEMBNeedleRetrieval">LEMBNeedleRetrieval</option>
                <option value="LEMBPasskeyRetrieval">LEMBPasskeyRetrieval</option>
            </select>
        </div>
        <div style="position: relative; height: 500px;">
            <canvas id="performanceChart"></canvas>
        </div>
    </div>



    <script>
        // Language data for internationalization
        const i18nData = {
            en: {
                'page.title': 'vLLM Long Text Embedding Chunked Processing Test Results',
                'page.subtitle': 'Evaluating the performance of different pooling aggregation strategies in long text embedding tasks',
                'summary.title': 'ğŸ“Š Test Results Summary',
                'summary.description': 'Following PR reviewer recommendations, we tested three core models plus two additional Qwen models (supporting 32k context) to provide comprehensive analysis:',
                'summary.metrics.label': 'Evaluation Metrics:',
                'summary.metrics.description': 'Using ndcg_at_10 metric to measure model performance on LEMBNeedleRetrieval and LEMBPasskeyRetrieval tasks.',
                'highlight.title': 'Outstanding Performance: Qwen3-Embedding-4B Long Text Processing',
                'highlight.description': 'demonstrates exceptional long text processing capabilities under LAST pooling:',
                'highlight.score1': 'PasskeyRetrieval achieves',
                'highlight.score2': 'PasskeyRetrieval maintains',
                'highlight.score.unit': 'score',
                'highlight.conclusion': 'This proves that chunked processing technology can maintain excellent performance even when <strong>exceeding native 32k context limits</strong>!',
                'loading.text': 'Loading test results...',
                'controls.title': 'ğŸ” Performance Chart Viewer',
                'controls.description': 'Select model and pooling type to add to the performance chart:',
                'controls.model.label': 'Model:',
                'controls.model.placeholder': 'Select model',
                'controls.pooling.label': 'Pooling Type:',
                'controls.pooling.placeholder': 'Select pooling',
                'controls.add.button': 'Add to Chart',
                'controls.clear.button': 'Clear Chart',
                'details.title': 'Performance Chart',
                'chart.task.label': 'Task:',
                'conclusion.title': 'ğŸ¯ Key Findings and Conclusions',
                'conclusion.breakthrough.title': 'ğŸŒŸ Notable Achievement: Ultra-Long Text Processing Capability Validation',
                'conclusion.breakthrough.description': 'achieved <strong>excellent ultra-long text processing performance</strong> under LAST pooling: At extreme lengths of 34816 and 36864 tokens (exceeding the native 32k limit by 15%+), the PasskeyRetrieval task still maintains a <strong>near-perfect score of</strong>',
                'conclusion.breakthrough.suffix': ', providing strong performance validation for vLLM\'s chunked processing technology!',
                'conclusion.differences.title': 'Analysis of Aggregation Strategy Performance',
                'conclusion.differences.intro': 'Contrary to the assumption that "mean aggregation always performs better", our comprehensive test results reveal:',
                'conclusion.differences.point1.title': 'Native pooling types generally perform best:',
                'conclusion.differences.point1.desc': '4 out of 5 models achieved highest scores with their native pooling types',
                'conclusion.differences.point2.title': 'MEAN aggregation is not a universal solution:',
                'conclusion.differences.point2.desc': 'For native LAST models, LAST aggregation significantly outperforms MEAN aggregation',
                'conclusion.differences.point3.title': 'Interesting exception:',
                'conclusion.differences.point3.desc': 'Although ibm-granite model is natively CLS, MEAN aggregation performs best',
                'conclusion.effectiveness.title': 'Practical Effects of Chunked Processing',
                'conclusion.effectiveness.intro': 'Ultra-long text testing of Qwen models (34816, 36864 tokens) proves the effectiveness of chunked processing:',
                'conclusion.effectiveness.point1.title': 'ğŸŒŸ Qwen3-Embedding-4B shows outstanding performance:',
                'conclusion.effectiveness.point1.desc': 'Under LAST aggregation, even exceeding the native 32k context limit, PasskeyRetrieval task still maintains a high score of',
                'conclusion.effectiveness.point1.suffix': '',
                'conclusion.effectiveness.point2.title': 'Technical validation:',
                'conclusion.effectiveness.point2.desc': 'This is the first proof that chunked processing technology can maintain near-native performance on ultra-long texts',
                'conclusion.effectiveness.point3.title': 'Practical value:',
                'conclusion.effectiveness.point3.desc': 'Provides a viable technical solution for handling ultra-long documents, code repositories, and other scenarios',
                'conclusion.recommendation.title': 'Implementation Strategy Recommendations',
                'conclusion.recommendation.stance': 'Based on these test results, maintaining the current flexible implementation approach is recommended',
                'conclusion.recommendation.intro': ', for the following reasons:',
                'conclusion.recommendation.point1.title': 'Significant performance differences:',
                'conclusion.recommendation.point1.desc': 'Performance differences between aggregation methods are substantial; forcing MEAN usage would severely damage some models\' performance',
                'conclusion.recommendation.point2.title': 'Model diversity:',
                'conclusion.recommendation.point2.desc': 'Real applications encounter various native pooling types, requiring flexibility',
                'conclusion.recommendation.point3.title': 'User choice:',
                'conclusion.recommendation.point3.desc': 'Users should be allowed to choose the aggregation method most suitable for their models',
                'conclusion.recommendation.suggestion.title': 'Recommended approach:',
                'conclusion.recommendation.suggestion.desc': 'Maintain the current implementation that allows users to select aggregation strategies through configuration. Documentation should clearly indicate that for optimal performance, users should choose aggregation methods consistent with their model\'s native pooling type. This approach provides necessary flexibility while enabling optimal results across diverse model architectures.',
                'model.native': 'native',
                'model.aggregation': ' aggregation',
                'model.data.missing': 'Data Missing',
                'model.excellent.long': 'âš¡Excellent Long Text',
                'details.select.complete': 'Please select model and pooling type',
                'highlight.chart.title': 'Performance Chart: Ultra-Long Text Processing',
                'highlight.chart.note': '32k context limit highlighted in red dashed line',
                'highlight.chart.qwen.title': 'Qwen3-Embedding-4B (LAST Pooling) - Ultra-Long Text Performance'
            },
            zh: {
                'page.title': 'vLLMé•¿æ–‡æœ¬åµŒå…¥åˆ†ç‰‡å¤„ç†æµ‹è¯•ç»“æœ',
                'page.subtitle': 'è¯„ä¼°ä¸åŒpoolingèšåˆç­–ç•¥åœ¨é•¿æ–‡æœ¬åµŒå…¥ä»»åŠ¡ä¸­çš„æ€§èƒ½è¡¨ç°',
                'summary.title': 'ğŸ“Š æµ‹è¯•ç»“æœæ±‡æ€»',
                'summary.description': 'æ ¹æ®PRå®¡æ ¸å‘˜å»ºè®®ï¼Œæˆ‘ä»¬æµ‹è¯•äº†ä¸‰ä¸ªæ ¸å¿ƒæ¨¡å‹ï¼ŒåŒæ—¶åŒ…å«äº†ä¸¤ä¸ªé¢å¤–çš„Qwenæ¨¡å‹ï¼ˆæ”¯æŒ32kä¸Šä¸‹æ–‡ï¼‰ä»¥æä¾›å…¨é¢çš„åˆ†æï¼š',
                'summary.metrics.label': 'è¯„ä¼°æŒ‡æ ‡ï¼š',
                'summary.metrics.description': 'ä½¿ç”¨ ndcg_at_10 æŒ‡æ ‡è¡¡é‡æ¨¡å‹æ€§èƒ½ï¼Œåˆ†åˆ«åœ¨ LEMBNeedleRetrieval å’Œ LEMBPasskeyRetrieval ä»»åŠ¡ä¸Šè¿›è¡Œæµ‹è¯•ã€‚',
                'highlight.title': 'çªå‡ºè¡¨ç°ï¼šQwen3-Embedding-4Bè¶…é•¿æ–‡æœ¬å¤„ç†',
                'highlight.description': 'åœ¨LAST poolingä¸‹å±•ç°äº†å“è¶Šçš„è¶…é•¿æ–‡æœ¬å¤„ç†èƒ½åŠ›ï¼š',
                'highlight.score1': 'PasskeyRetrievalè¾¾åˆ°',
                'highlight.score2': 'PasskeyRetrievalç»´æŒ',
                'highlight.score.unit': 'åˆ†',
                'highlight.conclusion': 'è¿™è¯æ˜äº†åˆ†ç‰‡å¤„ç†æŠ€æœ¯åœ¨<strong>è¶…å‡ºåŸç”Ÿ32kä¸Šä¸‹æ–‡é™åˆ¶</strong>æ—¶ä»èƒ½ä¿æŒä¼˜å¼‚æ€§èƒ½ï¼',
                'loading.text': 'æ­£åœ¨åŠ è½½æµ‹è¯•ç»“æœ...',
                'controls.title': 'ğŸ” æ€§èƒ½å›¾è¡¨æŸ¥çœ‹å™¨',
                'controls.description': 'é€‰æ‹©æ¨¡å‹å’Œpoolingç±»å‹æ·»åŠ åˆ°æ€§èƒ½å›¾è¡¨ä¸­ï¼š',
                'controls.model.label': 'æ¨¡å‹ï¼š',
                'controls.model.placeholder': 'è¯·é€‰æ‹©æ¨¡å‹',
                'controls.pooling.label': 'Poolingç±»å‹ï¼š',
                'controls.pooling.placeholder': 'è¯·é€‰æ‹©Pooling',
                'controls.add.button': 'æ·»åŠ åˆ°å›¾è¡¨',
                'controls.clear.button': 'æ¸…ç©ºå›¾è¡¨',
                'details.title': 'æ€§èƒ½å›¾è¡¨',
                'chart.task.label': 'ä»»åŠ¡ï¼š',
                'conclusion.title': 'ğŸ¯ å…³é”®å‘ç°ä¸ç»“è®º',
                'conclusion.breakthrough.title': 'ğŸŒŸ æ˜¾è‘—æˆæœï¼šè¶…é•¿æ–‡æœ¬å¤„ç†èƒ½åŠ›éªŒè¯',
                'conclusion.breakthrough.description': 'åœ¨LAST poolingä¸‹å®ç°äº†<strong>ä¼˜å¼‚çš„è¶…é•¿æ–‡æœ¬å¤„ç†æ€§èƒ½</strong>ï¼šåœ¨34816å’Œ36864 tokensï¼ˆè¶…å‡º32kåŸç”Ÿé™åˆ¶15%+ï¼‰çš„æç«¯é•¿åº¦ä¸‹ï¼ŒPasskeyRetrievalä»»åŠ¡ä»ç»´æŒ<strong>',
                'conclusion.breakthrough.suffix': 'çš„è¿‘å®Œç¾åˆ†æ•°</strong>ï¼Œè¿™ä¸ºvLLMçš„åˆ†ç‰‡å¤„ç†æŠ€æœ¯æä¾›äº†å¼ºæœ‰åŠ›çš„æ€§èƒ½éªŒè¯ï¼',
                'conclusion.differences.title': 'èšåˆç­–ç•¥æ€§èƒ½åˆ†æ',
                'conclusion.differences.intro': 'ä¸"mean aggregation always performs better"çš„å‡è®¾ç›¸åï¼Œæˆ‘ä»¬çš„å…¨é¢æµ‹è¯•ç»“æœè¡¨æ˜ï¼š',
                'conclusion.differences.point1.title': 'åŸç”Ÿpoolingç±»å‹æ™®éè¡¨ç°æœ€ä½³ï¼š',
                'conclusion.differences.point1.desc': '5ä¸ªæ¨¡å‹ä¸­æœ‰4ä¸ªåœ¨åŸç”Ÿpoolingç±»å‹ä¸‹è·å¾—æœ€é«˜åˆ†æ•°',
                'conclusion.differences.point2.title': 'MEANèšåˆå¹¶éä¸‡èƒ½è§£å†³æ–¹æ¡ˆï¼š',
                'conclusion.differences.point2.desc': 'å¯¹äºåŸç”ŸLASTæ¨¡å‹ï¼ŒLASTèšåˆæ˜¾è‘—ä¼˜äºMEANèšåˆ',
                'conclusion.differences.point3.title': 'æœ‰è¶£çš„ä¾‹å¤–ï¼š',
                'conclusion.differences.point3.desc': 'ibm-graniteæ¨¡å‹è™½ç„¶åŸç”Ÿæ˜¯CLSï¼Œä½†MEANèšåˆè¡¨ç°æœ€å¥½',
                'conclusion.effectiveness.title': 'åˆ†ç‰‡å¤„ç†çš„å®é™…æ•ˆæœ',
                'conclusion.effectiveness.intro': 'Qwenæ¨¡å‹çš„è¶…é•¿æ–‡æœ¬æµ‹è¯•ï¼ˆ34816ã€36864 tokensï¼‰è¯æ˜äº†åˆ†ç‰‡å¤„ç†çš„æœ‰æ•ˆæ€§ï¼š',
                'conclusion.effectiveness.point1.title': 'ğŸŒŸ Qwen3-Embedding-4Bè¡¨ç°çªå‡ºï¼š',
                'conclusion.effectiveness.point1.desc': 'åœ¨LASTèšåˆä¸‹ï¼Œå³ä½¿è¶…å‡ºåŸç”Ÿ32kä¸Šä¸‹æ–‡é™åˆ¶ï¼ŒPasskeyRetrievalä»»åŠ¡ä»ä¿æŒ',
                'conclusion.effectiveness.point1.suffix': 'çš„é«˜åˆ†',
                'conclusion.effectiveness.point2.title': 'æŠ€æœ¯éªŒè¯ï¼š',
                'conclusion.effectiveness.point2.desc': 'è¿™æ˜¯é¦–æ¬¡è¯æ˜åˆ†ç‰‡å¤„ç†æŠ€æœ¯èƒ½åœ¨è¶…é•¿æ–‡æœ¬ä¸Šç»´æŒæ¥è¿‘åŸç”Ÿæ€§èƒ½',
                'conclusion.effectiveness.point3.title': 'å®ç”¨ä»·å€¼ï¼š',
                'conclusion.effectiveness.point3.desc': 'ä¸ºå¤„ç†è¶…é•¿æ–‡æ¡£ã€ä»£ç åº“ç­‰åœºæ™¯æä¾›äº†å¯è¡Œçš„æŠ€æœ¯æ–¹æ¡ˆ',
                'conclusion.recommendation.title': 'å®ç°ç­–ç•¥å»ºè®®',
                'conclusion.recommendation.stance': 'åŸºäºæµ‹è¯•ç»“æœï¼Œå»ºè®®ä¿æŒå½“å‰çµæ´»çš„å®ç°æ–¹å¼',
                'conclusion.recommendation.intro': 'ï¼ŒåŸå› å¦‚ä¸‹ï¼š',
                'conclusion.recommendation.point1.title': 'æ€§èƒ½å·®å¼‚æ˜¾è‘—ï¼š',
                'conclusion.recommendation.point1.desc': 'ä¸åŒèšåˆæ–¹å¼çš„æ€§èƒ½å·®å¼‚å¾ˆå¤§ï¼Œå¼ºåˆ¶ä½¿ç”¨MEANä¼šä¸¥é‡æŸå®³æŸäº›æ¨¡å‹çš„æ€§èƒ½',
                'conclusion.recommendation.point2.title': 'æ¨¡å‹å¤šæ ·æ€§ï¼š',
                'conclusion.recommendation.point2.desc': 'å®é™…åº”ç”¨ä¸­ä¼šé‡åˆ°å„ç§åŸç”Ÿpoolingç±»å‹çš„æ¨¡å‹ï¼Œéœ€è¦ä¿æŒçµæ´»æ€§',
                'conclusion.recommendation.point3.title': 'ç”¨æˆ·é€‰æ‹©æƒï¼š',
                'conclusion.recommendation.point3.desc': 'åº”è¯¥è®©ç”¨æˆ·é€‰æ‹©æœ€é€‚åˆå…¶æ¨¡å‹çš„èšåˆæ–¹å¼',
                'conclusion.recommendation.suggestion.title': 'å»ºè®®æ–¹æ¡ˆï¼š',
                'conclusion.recommendation.suggestion.desc': 'ä¿æŒå½“å‰å…è®¸ç”¨æˆ·é€šè¿‡é…ç½®é€‰æ‹©èšåˆç­–ç•¥çš„å®ç°æ–¹å¼ã€‚æ–‡æ¡£åº”æ˜ç¡®è¯´æ˜ï¼Œä¸ºè·å¾—æœ€ä½³æ€§èƒ½ï¼Œç”¨æˆ·åº”é€‰æ‹©ä¸å…¶æ¨¡å‹åŸç”Ÿpoolingç±»å‹ä¸€è‡´çš„èšåˆæ–¹å¼ã€‚è¿™ç§æ–¹æ³•åœ¨æä¾›å¿…è¦çµæ´»æ€§çš„åŒæ—¶ï¼Œèƒ½å¤Ÿåœ¨å¤šæ ·åŒ–çš„æ¨¡å‹æ¶æ„ä¸Šå®ç°æœ€ä¼˜ç»“æœã€‚',
                'model.native': 'åŸç”Ÿ',
                'model.aggregation': 'èšåˆ',
                'model.data.missing': 'æ•°æ®ç¼ºå¤±',
                'model.excellent.long': 'âš¡è¶…é•¿æ–‡æœ¬ä¼˜å¼‚',
                'details.select.complete': 'è¯·é€‰æ‹©æ¨¡å‹å’ŒPoolingç±»å‹',
                'highlight.chart.title': 'æ€§èƒ½å›¾è¡¨ï¼šè¶…é•¿æ–‡æœ¬å¤„ç†',
                'highlight.chart.note': 'çº¢è‰²è™šçº¿æ ‡ç¤º32kä¸Šä¸‹æ–‡é™åˆ¶',
                'highlight.chart.qwen.title': 'Qwen3-Embedding-4B (LAST Pooling) - è¶…é•¿æ–‡æœ¬æ€§èƒ½è¡¨ç°'
            }
        };

        // Current language (default to English)
        let currentLanguage = 'en';

        // Language switching function
        function switchLanguage(lang) {
            currentLanguage = lang;
            document.documentElement.lang = lang;
            document.title = i18nData[lang]['page.title'];
            
            // Update language buttons
            document.querySelectorAll('.language-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent === (lang === 'en' ? 'EN' : 'ä¸­æ–‡')) {
                    btn.classList.add('active');
                }
            });
            
            // Update all text elements with data-i18n attributes
            document.querySelectorAll('[data-i18n]').forEach(element => {
                const key = element.getAttribute('data-i18n');
                if (i18nData[lang][key]) {
                    element.innerHTML = i18nData[lang][key];
                }
            });
            
            // Reload model results to update dynamic content
            loadAllResults();
            
            // Update chart legend if chart exists
            if (typeof updateChartLegend === 'function') {
                updateChartLegend();
            }
            
            // Update Qwen chart language
            updateQwenChartLanguage();
        }

        // Helper function to get translated text
        function t(key) {
            return i18nData[currentLanguage][key] || key;
        }

        // Get Qwen chart title based on current language
        function getQwenChartTitle() {
            return t('highlight.chart.qwen.title');
        }

        // Update Qwen chart language
        function updateQwenChartLanguage() {
            if (qwenChart) {
                qwenChart.options.plugins.title.text = getQwenChartTitle();
                qwenChart.update();
            }
        }

        // æ¨¡å‹é…ç½®ä¿¡æ¯
        const modelConfigs = {
            'BAAI_bge-multilingual-gemma2': {
                name: 'BAAI/bge-multilingual-gemma2',
                nativePooling: 'LAST',
                context: '8k',
                path: 'BAAI/bge-multilingual-gemma2_None-0_openai_local'
            },
            'intfloat_multilingual-e5-large': {
                name: 'intfloat/multilingual-e5-large',
                nativePooling: 'MEAN',
                context: '514',
                path: 'intfloat/multilingual-e5-large_None-0_openai_local'
            },
            'ibm-granite_granite-embedding-278m-multilingual': {
                name: 'ibm-granite/granite-embedding-278m-multilingual',
                nativePooling: 'CLS',
                context: '514',
                path: 'ibm-granite/granite-embedding-278m-multilingual_None-0_openai_local'
            },
            'Qwen_Qwen3-Embedding-0.6B': {
                name: 'Qwen/Qwen3-Embedding-0.6B',
                nativePooling: 'LAST',
                context: '32k',
                path: 'Qwen/Qwen3-Embedding-0.6B_None-0_openai_local'
            },
            'Qwen_Qwen3-Embedding-4B': {
                name: 'Qwen/Qwen3-Embedding-4B',
                nativePooling: 'LAST',
                context: '32k',
                path: 'Qwen/Qwen3-Embedding-4B_None-0_openai_local'
            }
        };

        // åŠ è½½æ‰€æœ‰æ¨¡å‹çš„overall_results
        async function loadAllResults() {
            const modelResultsDiv = document.getElementById('modelResults');
            modelResultsDiv.innerHTML = '';
            
            const modelSelect = document.getElementById('modelSelect');
            modelSelect.innerHTML = `<option value="">${t('controls.model.placeholder')}</option>`;

            for (const [modelKey, config] of Object.entries(modelConfigs)) {
                // æ·»åŠ åˆ°é€‰æ‹©æ¡†
                const option = document.createElement('option');
                option.value = modelKey;
                option.text = config.name;
                modelSelect.appendChild(option);

                // åˆ›å»ºæ¨¡å‹å¡ç‰‡
                const modelCard = document.createElement('div');
                modelCard.className = 'model-card';
                
                let cardHTML = `
                    <div class="model-title">
                        ${config.name} 
                        <span style="font-size: 0.8rem; color: #666;">
                            (${t('model.native')}${config.nativePooling} pooling, ${config.context} context)
                        </span>
                    </div>
                `;

                const poolingTypes = ['MEAN', 'LAST', 'CLS'];
                const results = {};
                
                // åŠ è½½å„ç§poolingç±»å‹çš„ç»“æœ
                for (const pooling of poolingTypes) {
                    try {
                        let pathSuffix = '';
                        if (pooling === 'LAST') {
                            pathSuffix = '_pool_last';
                        } else if (pooling === 'CLS') {
                            pathSuffix = '_pool_cls';
                        }
                        // åŸç”ŸMEANä¸éœ€è¦åç¼€ï¼Œå…¶ä»–æƒ…å†µéƒ½éœ€è¦åç¼€
                        
                        const url = `results/vllm_original_length/${pooling}/${modelKey}/${config.path}${pathSuffix}/overall_results.json`;
                        const response = await fetch(url);
                        
                        if (response.ok) {
                            const data = await response.json();
                            results[pooling] = data;
                        } else {
                            console.warn(`Failed to load ${url}`);
                        }
                    } catch (error) {
                        console.warn(`Error loading ${pooling} results for ${modelKey}:`, error);
                    }
                }
                
                // æ‰¾å‡ºæœ€ä½³æ€§èƒ½çš„poolingç±»å‹
                let bestPooling = config.nativePooling;
                let bestScore = 0;
                
                for (const [pooling, data] of Object.entries(results)) {
                    if (data && data.LEMBNeedleRetrieval && data.LEMBPasskeyRetrieval) {
                        const avgScore = (data.LEMBNeedleRetrieval.avg + data.LEMBPasskeyRetrieval.avg) / 2;
                        if (avgScore > bestScore) {
                            bestScore = avgScore;
                            bestPooling = pooling;
                        }
                    }
                }
                
                // æ˜¾ç¤ºç»“æœ
                for (const pooling of poolingTypes) {
                    const data = results[pooling];
                    const isBest = pooling === bestPooling;
                    const isNative = pooling === config.nativePooling;
                    
                    if (data && data.LEMBNeedleRetrieval && data.LEMBPasskeyRetrieval) {
                        const needleScore = data.LEMBNeedleRetrieval.avg.toFixed(4);
                        const passkeyScore = data.LEMBPasskeyRetrieval.avg.toFixed(4);
                        
                        // ç‰¹åˆ«æ ‡æ³¨Qwen3-Embedding-4Båœ¨LAST poolingä¸‹çš„è¶…é•¿æ–‡æœ¬è¡¨ç°
                        let specialNote = '';
                        if (modelKey === 'Qwen_Qwen3-Embedding-4B' && pooling === 'LAST') {
                            specialNote = ` <span style="color: #28a745; font-size: 0.8rem;">${t('model.excellent.long')}</span>`;
                        }
                        
                        cardHTML += `
                            <div class="pooling-result ${isBest ? 'best' : 'normal'}">
                                <span>
                                    ${isBest ? 'ğŸ† ' : ''}
                                    <strong>${pooling}${t('model.aggregation')}${isNative ? ` (${t('model.native')})` : ''}</strong>${specialNote}
                                </span>
                                <span class="score">${needleScore}/${passkeyScore}</span>
                            </div>
                        `;
                    } else {
                        cardHTML += `
                            <div class="pooling-result normal">
                                <span><strong>${pooling}${t('model.aggregation')}${isNative ? ` (${t('model.native')})` : ''}</strong></span>
                                <span class="score" style="color: #999;">${t('model.data.missing')}</span>
                            </div>
                        `;
                    }
                }

                modelCard.innerHTML = cardHTML;
                modelResultsDiv.appendChild(modelCard);
            }
        }

        // Chart instance
        let performanceChart = null;
        let chartDatasets = [];
        let qwenChart = null;
        
        // Initialize chart
        function initChart() {
            const ctx = document.getElementById('performanceChart').getContext('2d');
            performanceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Performance Comparison (ndcg_at_10)'
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Context Length (tokens)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'ndcg_at_10 Score'
                            },
                            min: 0,
                            max: 1
                        }
                    },
                    elements: {
                        line: {
                            tension: 0.1
                        },
                        point: {
                            radius: 4,
                            hoverRadius: 6
                        }
                    }
                }
            });
            
            // Update chart when task selection changes
            document.getElementById('taskSelect').addEventListener('change', updateChartData);
        }

        // Initialize Qwen3-Embedding-4B performance chart
        async function initQwenChart() {
            const ctx = document.getElementById('qwenPerformanceChart').getContext('2d');
            
            try {
                // Load Qwen3-Embedding-4B LAST pooling data
                const response = await fetch('results/vllm_original_length/LAST/Qwen_Qwen3-Embedding-4B/Qwen/Qwen3-Embedding-4B_None-0_openai_local_pool_last/overall_results.json');
                
                if (!response.ok) {
                    throw new Error('Failed to load data');
                }
                
                const data = await response.json();
                
                // Context lengths including ultra-long ones
                const contexts = ['256', '512', '1024', '2048', '4096', '8192', '16384', '32768', '34816', '36864'];
                const contextNumbers = contexts.map(c => parseInt(c));
                
                // Prepare data for both tasks
                const needleData = contexts.map(context => 
                    data.LEMBNeedleRetrieval && data.LEMBNeedleRetrieval[context] !== undefined 
                        ? data.LEMBNeedleRetrieval[context] 
                        : null
                );
                
                const passkeyData = contexts.map(context => 
                    data.LEMBPasskeyRetrieval && data.LEMBPasskeyRetrieval[context] !== undefined 
                        ? data.LEMBPasskeyRetrieval[context] 
                        : null
                );
                
                qwenChart = new Chart(ctx, {
                    type: 'line',
                    plugins: [window['chartjs-plugin-annotation']],
                    data: {
                        labels: contexts,
                        datasets: [
                            {
                                label: 'LEMBNeedleRetrieval',
                                data: needleData,
                                borderColor: '#28a745',
                                backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                borderWidth: 3,
                                fill: false,
                                tension: 0.1,
                                pointRadius: 5,
                                pointHoverRadius: 7
                            },
                            {
                                label: 'LEMBPasskeyRetrieval',
                                data: passkeyData,
                                borderColor: '#20c997',
                                backgroundColor: 'rgba(32, 201, 151, 0.1)',
                                borderWidth: 3,
                                fill: false,
                                tension: 0.1,
                                pointRadius: 5,
                                pointHoverRadius: 7
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: getQwenChartTitle(),
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            annotation: {
                                annotations: {
                                    line1: {
                                        type: 'line',
                                        xMin: 7,  // Index of 32768 in contexts array
                                        xMax: 7,
                                        borderColor: '#dc3545',
                                        borderWidth: 2,
                                        borderDash: [5, 5],
                                        label: {
                                            content: '32k Limit',
                                            enabled: true,
                                            position: 'end'
                                        }
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Context Length (tokens)',
                                    font: {
                                        weight: 'bold'
                                    }
                                },
                                ticks: {
                                    callback: function(value, index) {
                                        const label = this.getLabelForValue(value);
                                        const num = parseInt(label);
                                        // Highlight ultra-long contexts
                                        return num > 32768 ? `${label}*` : label;
                                    }
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'ndcg_at_10 Score',
                                    font: {
                                        weight: 'bold'
                                    }
                                },
                                min: 0,
                                max: 1.0,
                                ticks: {
                                    stepSize: 0.1
                                }
                            }
                        },
                        elements: {
                            line: {
                                tension: 0.1
                            },
                            point: {
                                pointStyle: function(ctx) {
                                    const index = ctx.dataIndex;
                                    const value = parseInt(contexts[index]);
                                    // Use different point style for ultra-long contexts
                                    return value > 32768 ? 'rectRot' : 'circle';
                                }
                            }
                        }
                    }
                });
                
            } catch (error) {
                console.error('Error loading Qwen chart data:', error);
                // Show error message in chart
                ctx.fillStyle = '#666';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Failed to load performance data', ctx.canvas.width / 2, ctx.canvas.height / 2);
            }
        }

        // Add model to chart
        async function addToChart() {
            const modelKey = document.getElementById('modelSelect').value;
            const pooling = document.getElementById('poolingSelect').value;
            
            if (!modelKey || !pooling) {
                alert(t('details.select.complete').replace('å®Œæ•´çš„é…ç½®ä¿¡æ¯', 'æ¨¡å‹å’ŒPoolingç±»å‹').replace('complete configuration information', 'model and pooling type'));
                return;
            }
            
            // Check if this combination already exists
            const datasetLabel = `${modelConfigs[modelKey].name} (${pooling})`;
            if (chartDatasets.find(d => d.label === datasetLabel)) {
                alert(currentLanguage === 'zh' ? 'è¯¥æ¨¡å‹ç»„åˆå·²å­˜åœ¨' : 'This model combination already exists');
                return;
            }
            
            try {
                const config = modelConfigs[modelKey];
                let pathSuffix = '';
                
                if (pooling === 'LAST') {
                    pathSuffix = '_pool_last';
                } else if (pooling === 'CLS') {
                    pathSuffix = '_pool_cls';
                }
                
                // Load overall results
                const url = `results/vllm_original_length/${pooling}/${modelKey}/${config.path}${pathSuffix}/overall_results.json`;
                const response = await fetch(url);
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Get context lengths and sort them numerically
                    const contexts = ['256', '512', '1024', '2048', '4096', '8192', '16384', '32768'];
                    if (modelKey.includes('Qwen')) {
                        contexts.push('34816', '36864');
                    }
                    
                    // Generate random color for this dataset
                    const colors = [
                        '#667eea', '#f093fb', '#4facfe', '#43e97b', '#fa709a',
                        '#ffecd2', '#fcb69f', '#a8edea', '#fed6e3', '#d299c2'
                    ];
                    const color = colors[chartDatasets.length % colors.length];
                    
                    // Create dataset
                    const dataset = {
                        label: datasetLabel,
                        data: [],
                        borderColor: color,
                        backgroundColor: color + '20',
                        borderWidth: 2,
                        fill: false
                    };
                    
                    // Add to datasets
                    chartDatasets.push({
                        ...dataset,
                        rawData: data,
                        modelKey,
                        pooling,
                        contexts: contexts
                    });
                    
                    // Update chart labels if needed
                    if (performanceChart.data.labels.length === 0) {
                        performanceChart.data.labels = contexts;
                    }
                    
                    // Update chart data
                    updateChartData();
                    updateChartLegend();
                    
                } else {
                    alert(currentLanguage === 'zh' ? 'æ— æ³•åŠ è½½æ•°æ®' : 'Failed to load data');
                }
            } catch (error) {
                alert(`${currentLanguage === 'zh' ? 'åŠ è½½é”™è¯¯: ' : 'Loading error: '}${error.message}`);
            }
        }
        
        // Update chart data based on selected task
        function updateChartData() {
            if (!performanceChart || chartDatasets.length === 0) return;
            
            const selectedTask = document.getElementById('taskSelect').value;
            
            performanceChart.data.datasets = chartDatasets.map(dataset => {
                const data = [];
                dataset.contexts.forEach(context => {
                    if (dataset.rawData[selectedTask] && dataset.rawData[selectedTask][context] !== undefined) {
                        data.push(dataset.rawData[selectedTask][context]);
                    } else {
                        data.push(null);
                    }
                });
                
                return {
                    ...dataset,
                    data: data
                };
            });
            
            performanceChart.options.plugins.title.text = `${selectedTask} Performance Comparison (ndcg_at_10)`;
            performanceChart.update();
        }
        
        // Clear chart
        function clearChart() {
            chartDatasets = [];
            if (performanceChart) {
                performanceChart.data.datasets = [];
                performanceChart.data.labels = [];
                performanceChart.update();
            }
            updateChartLegend();
        }
        
        // Update chart legend
        function updateChartLegend() {
            const legendDiv = document.getElementById('chartLegend');
            if (chartDatasets.length === 0) {
                legendDiv.innerHTML = `<em>${currentLanguage === 'zh' ? 'é€‰æ‹©æ¨¡å‹å’ŒPoolingç±»å‹å¼€å§‹å¯¹æ¯”' : 'Select model and pooling type to start comparison'}</em>`;
            } else {
                const legendItems = chartDatasets.map((dataset, index) => {
                    const config = modelConfigs[dataset.modelKey];
                    const isNative = config.nativePooling === dataset.pooling;
                    return `<span style="color: ${dataset.borderColor}; font-weight: bold;">â—</span> ${dataset.label}${isNative ? ` (${t('model.native')})` : ''}`;
                }).join(' | ');
                legendDiv.innerHTML = `<strong>${currentLanguage === 'zh' ? 'å›¾è¡¨ä¸­çš„æ¨¡å‹:' : 'Models in chart:'}</strong> ${legendItems}`;
            }
        }



        // Load Qwen3-Embedding-4B highlight scores
        async function loadQwenHighlightScores() {
            try {
                const response = await fetch('results/vllm_original_length/LAST/Qwen_Qwen3-Embedding-4B/Qwen/Qwen3-Embedding-4B_None-0_openai_local_pool_last/overall_results.json');
                if (response.ok) {
                    const data = await response.json();
                    
                    // Update individual scores
                    const score34816 = data.LEMBPasskeyRetrieval['34816'];
                    const score36864 = data.LEMBPasskeyRetrieval['36864'];
                    
                    if (score34816 !== undefined) {
                        document.getElementById('score-34816').textContent = score34816;
                    }
                    if (score36864 !== undefined) {
                        document.getElementById('score-36864').textContent = score36864;
                    }
                    
                    // Update conclusion scores (use average of ultra-long scores for representative value)
                    if (score34816 !== undefined && score36864 !== undefined) {
                        const representativeScore = score34816; // In this case both are 0.98, but we could use average
                        document.getElementById('conclusion-score').textContent = representativeScore;
                        document.getElementById('effectiveness-score').textContent = representativeScore;
                    } else if (score34816 !== undefined) {
                        document.getElementById('conclusion-score').textContent = score34816;
                        document.getElementById('effectiveness-score').textContent = score34816;
                    } else if (score36864 !== undefined) {
                        document.getElementById('conclusion-score').textContent = score36864;
                        document.getElementById('effectiveness-score').textContent = score36864;
                    }
                } else {
                    console.warn('Failed to load Qwen highlight scores');
                    // Set fallback values
                    document.getElementById('score-34816').textContent = 'N/A';
                    document.getElementById('score-36864').textContent = 'N/A';
                    document.getElementById('conclusion-score').textContent = 'N/A';
                    document.getElementById('effectiveness-score').textContent = 'N/A';
                }
            } catch (error) {
                console.error('Error loading Qwen highlight scores:', error);
                // Set fallback values
                document.getElementById('score-34816').textContent = 'N/A';
                document.getElementById('score-36864').textContent = 'N/A';
                document.getElementById('conclusion-score').textContent = 'N/A';
                document.getElementById('effectiveness-score').textContent = 'N/A';
            }
        }

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        window.addEventListener('load', function() {
            // Initialize with English language
            switchLanguage('en');
            // Load dynamic highlight scores
            loadQwenHighlightScores();
            // Initialize chart
            initChart();
            // Initialize chart legend
            updateChartLegend();
            // Initialize Qwen performance chart
            initQwenChart();
        });
    </script>
</body>
</html> 